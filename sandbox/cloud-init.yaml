#cloud-config
# Sandbox Droplet Configuration
# This is used to create the snapshot that sandboxes spawn from

package_update: true
package_upgrade: true

packages:
  - docker.io
  - docker-compose
  - iptables-persistent
  - curl
  - jq
  - python3
  - dnsutils

write_files:
  # Docker daemon configuration
  - path: /etc/docker/daemon.json
    content: |
      {
        "log-driver": "json-file",
        "log-opts": {
          "max-size": "10m",
          "max-file": "3"
        },
        "storage-driver": "overlay2"
      }

  # Network policy script
  - path: /opt/sandbox/network-policy.sh
    permissions: '0755'
    content: |
      #!/bin/bash
      set -e
      
      CONFIG_FILE="/opt/sandbox/network-config.json"
      
      # Flush existing DOCKER-USER rules
      iptables -F DOCKER-USER 2>/dev/null || true
      
      # Accept established connections
      iptables -A DOCKER-USER -m conntrack --ctstate ESTABLISHED,RELATED -j ACCEPT
      
      # Get container IPs
      get_ip() {
          docker inspect -f '{{range .NetworkSettings.Networks}}{{.IPAddress}}{{end}}' "$1" 2>/dev/null || echo ""
      }
      
      apply_rules() {
          local container=$1
          local ip=$(get_ip "$container")
          [ -z "$ip" ] && return
          
          local egress=$(jq -r ".containers.\"$container\".egress // \"none\"" "$CONFIG_FILE")
          
          case "$egress" in
              "none")
                  iptables -A DOCKER-USER -s "$ip" -p udp --dport 53 -j ACCEPT
                  iptables -A DOCKER-USER -s "$ip" ! -d 172.16.0.0/12 -j DROP
                  ;;
              "allowlist")
                  iptables -A DOCKER-USER -s "$ip" -p udp --dport 53 -j ACCEPT
                  for domain in $(jq -r ".containers.\"$container\".allowed_domains[]?" "$CONFIG_FILE"); do
                      clean=$(echo "$domain" | sed 's/^\*\.//')
                      for resolved in $(dig +short "$clean" 2>/dev/null | grep -E '^[0-9]' || true); do
                          iptables -A DOCKER-USER -s "$ip" -d "$resolved" -j ACCEPT
                      done
                  done
                  iptables -A DOCKER-USER -s "$ip" ! -d 172.16.0.0/12 -j DROP
                  ;;
              "all")
                  iptables -A DOCKER-USER -s "$ip" -j ACCEPT
                  ;;
          esac
      }
      
      [ -f "$CONFIG_FILE" ] && {
          for c in container-1 container-2 container-3 container-4; do
              apply_rules "$c"
          done
      }
      
      iptables -A DOCKER-USER -j RETURN
      echo "Network policies applied"

  # Network agent
  - path: /opt/sandbox/network-agent.py
    permissions: '0755'
    content: |
      #!/usr/bin/env python3
      import json, subprocess
      from http.server import HTTPServer, BaseHTTPRequestHandler
      
      class Handler(BaseHTTPRequestHandler):
          def do_POST(self):
              if self.path == "/network/apply":
                  body = self.rfile.read(int(self.headers.get('Content-Length', 0)))
                  try:
                      with open("/opt/sandbox/network-config.json", 'w') as f:
                          f.write(body.decode())
                      r = subprocess.run(["/opt/sandbox/network-policy.sh"], capture_output=True, text=True)
                      resp = {"status": "ok" if r.returncode == 0 else "error", "message": r.stdout or r.stderr}
                  except Exception as e:
                      resp = {"status": "error", "message": str(e)}
                  self.send_response(200)
                  self.send_header('Content-Type', 'application/json')
                  self.end_headers()
                  self.wfile.write(json.dumps(resp).encode())
              else:
                  self.send_response(404)
                  self.end_headers()
          
          def do_GET(self):
              if self.path == "/health":
                  self.send_response(200)
                  self.end_headers()
                  self.wfile.write(b'{"status":"ok"}')
              else:
                  self.send_response(404)
                  self.end_headers()
      
      HTTPServer(('0.0.0.0', 9999), Handler).serve_forever()

  # Systemd service for network agent
  - path: /etc/systemd/system/network-agent.service
    content: |
      [Unit]
      Description=Network Agent
      After=docker.service
      [Service]
      ExecStart=/usr/bin/python3 /opt/sandbox/network-agent.py
      Restart=always
      [Install]
      WantedBy=multi-user.target

  # Docker compose for containers
  - path: /opt/sandbox/docker-compose.yml
    content: |
      version: '3.8'
      
      services:
        container-1:
          image: alpine:latest
          container_name: container-1
          command: sh -c "apk add --no-cache bash && sleep infinity"
          restart: unless-stopped
          networks:
            - isolated_net
          cap_drop:
            - ALL
          security_opt:
            - no-new-privileges:true
          tmpfs:
            - /tmp
      
        container-2:
          image: alpine:latest
          container_name: container-2
          command: sh -c "apk add --no-cache bash && sleep infinity"
          restart: unless-stopped
          networks:
            - isolated_net
          cap_drop:
            - ALL
          security_opt:
            - no-new-privileges:true
          tmpfs:
            - /tmp
      
        container-3:
          image: alpine:latest
          container_name: container-3
          command: sh -c "apk add --no-cache bash && sleep infinity"
          restart: unless-stopped
          networks:
            - isolated_net
          cap_drop:
            - ALL
          security_opt:
            - no-new-privileges:true
          tmpfs:
            - /tmp
      
        container-4:
          image: ubuntu:24.04
          container_name: container-4
          command: bash -c "apt-get update && apt-get install -y curl && sleep infinity"
          restart: unless-stopped
          networks:
            - llm_net
          cap_drop:
            - ALL
          cap_add:
            - NET_BIND_SERVICE
          security_opt:
            - no-new-privileges:true
          volumes:
            - llm_data:/data
          environment:
            - RUNPOD_API_KEY=${RUNPOD_API_KEY:-}
      
      networks:
        isolated_net:
          driver: bridge
          internal: true
          ipam:
            config:
              - subnet: 172.20.0.0/16
        llm_net:
          driver: bridge
          ipam:
            config:
              - subnet: 172.21.0.0/16
      
      volumes:
        llm_data:

  # Default network config
  - path: /opt/sandbox/network-config.json
    content: |
      {
        "containers": {
          "container-1": {"egress": "none", "allowed_domains": []},
          "container-2": {"egress": "none", "allowed_domains": []},
          "container-3": {"egress": "none", "allowed_domains": []},
          "container-4": {"egress": "allowlist", "allowed_domains": ["api.runpod.ai", "api.runpod.net"]}
        },
        "inter_container": {"enabled": false, "rules": []}
      }

runcmd:
  - systemctl enable docker
  - systemctl start docker
  - systemctl enable network-agent
  - systemctl start network-agent
  - cd /opt/sandbox && docker-compose pull
  - cd /opt/sandbox && docker-compose up -d
  - sleep 10
  - /opt/sandbox/network-policy.sh
  - touch /opt/sandbox/.ready
